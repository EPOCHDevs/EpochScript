#pragma once
#include "storage_types.h"
#include <epoch_frame/dataframe.h>
#include <epoch_script/transforms/core/itransform.h>
#include <epoch_script/transforms/runtime/types.h>

namespace epoch_script::runtime {

class IIntermediateStorage {
public:
  virtual ~IIntermediateStorage() = default;

  // Gather inputs for a transform into a DataFrame
  [[nodiscard]] virtual epoch_frame::DataFrame
  GatherInputs(const AssetID &asset_id,
               const epoch_script::transform::ITransformBase &transformer) const = 0;

  // Gather inputs specifically for scalar transforms
  // Returns any available base data (any timeframe) for index extraction
  // Scalars don't need specific timeframe data - just a valid index
  [[nodiscard]] virtual epoch_frame::DataFrame
  GatherInputsForScalar(const AssetID &asset_id,
                       const epoch_script::transform::ITransformBase &transformer) const = 0;

  // Validate that all inputs are available for a transform before gathering
  // Returns true if all inputs exist, false if any are missing
  [[nodiscard]] virtual bool
  ValidateInputsAvailable(const AssetID &asset_id,
                         const epoch_script::transform::ITransformBase &transformer) const = 0;

  virtual TimeFrameAssetDataFrameMap BuildFinalOutput() = 0;

  // Initialize base data (OHLCV)
  virtual void InitializeBaseData(TimeFrameAssetDataFrameMap data,
                                  const std::unordered_set<AssetID> &allowed_asset_ids) = 0;

  // Register a transform with the cache - stores transform metadata for later queries
  virtual void RegisterTransform(const epoch_script::transform::ITransformBase &transform) = 0;

  virtual void StoreTransformOutput(
      const AssetID &asset_id,
      const epoch_script::transform::ITransformBase &transformer,
      const epoch_frame::DataFrame &data) = 0;

  // Store a pre-computed asset scalar (computed at orchestrator init time)
  // Used for asset_ref and similar per-asset constants
  virtual void StoreAssetScalar(const AssetID &asset_id,
                                const std::string &outputId,
                                const epoch_frame::Scalar &value) = 0;

  virtual std::vector<AssetID> GetAssetIDs() const = 0;

  // ===== Report Caching (for reporter transforms) =====

  // Store a report generated by a reporter transform
  // For per-asset reports, key is the asset ID
  // For cross-sectional reports, key is GROUP_KEY
  // Multiple reports with same key are merged
  virtual void StoreReport(const AssetID& key, const epoch_proto::TearSheet& report) = 0;

  // Get all cached reports (keyed by asset ID or GROUP_KEY)
  [[nodiscard]] virtual AssetReportMap GetCachedReports() const = 0;

  // ===== Event Marker Caching (for event_marker transforms) =====

  // Store an event marker generated by an event_marker transform
  virtual void StoreEventMarker(const AssetID& key, const epoch_script::transform::EventMarkerData& marker) = 0;

  // Get all cached event markers (keyed by asset ID)
  [[nodiscard]] virtual AssetEventMarkerMap GetCachedEventMarkers() const = 0;
};

using IIntermediateStoragePtr = std::unique_ptr<IIntermediateStorage>;
} // namespace epoch_script::runtime